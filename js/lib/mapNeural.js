class SimpleNeuralNet {
  constructor(i,h,o){this.numInputs=i;this.numHidden=h;this.numOutputs=o;this.weightsIH=[];for(let i=0;i<h;i++){this.weightsIH[i]=[];for(let j=0;j<this.numInputs;j++){this.weightsIH[i][j]=Math.random()*2-1;}}this.weightsHO=[];for(let i=0;i<o;i++){this.weightsHO[i]=[];for(let j=0;j<h;j++){this.weightsHO[i][j]=Math.random()*2-1;}}this.biasH=Array(h).fill(0).map(()=>Math.random()*2-1);this.biasO=Array(o).fill(0).map(()=>Math.random()*2-1);}
  static sigmoid(x){return 1/(1+Math.exp(-x));} static dsigmoid(y){return y*(1-y);} static matMulVector(A,v){const r=[];for(let i=0;i<A.length;i++){let s=0;for(let j=0;j<v.length;j++){s+=A[i][j]*v[j];}r[i]=s;}return r;} static vecAdd(v,u){return v.map((val,i)=>val+u[i]);} static vecSub(v,u){return v.map((val,i)=>val-u[i]);} static vecHadamard(v,u){return v.map((val,i)=>val*u[i]);}
  predict(a){const hI=SimpleNeuralNet.matMulVector(this.weightsIH,a);const hWB=SimpleNeuralNet.vecAdd(hI,this.biasH);const hO=hWB.map(SimpleNeuralNet.sigmoid);const fI=SimpleNeuralNet.matMulVector(this.weightsHO,hO);const fWB=SimpleNeuralNet.vecAdd(fI,this.biasO);const fO=fWB.map(SimpleNeuralNet.sigmoid);return{hiddenOutputs:hO,finalOutputs:fO};}
  train(inputs,targets,epochs=1e3,lr=.1){for(let e=0;e<epochs;e++){for(let i=0;i<inputs.length;i++){const a=inputs[i],t=targets[i];const{hiddenOutputs:hO,finalOutputs:fO}=this.predict(a);const oE=SimpleNeuralNet.vecSub(t,fO);const gO=SimpleNeuralNet.vecHadamard(fO.map(SimpleNeuralNet.dsigmoid),oE);for(let i=0;i<this.numOutputs;i++){for(let j=0;j<this.numHidden;j++){this.weightsHO[i][j]+=lr*gO[i]*hO[j];}this.biasO[i]+=lr*gO[i];}const wT=this.transpose(this.weightsHO),hE=SimpleNeuralNet.matMulVector(wT,oE);const gH=SimpleNeuralNet.vecHadamard(hO.map(SimpleNeuralNet.dsigmoid),hE);for(let i=0;i<this.numHidden;i++){for(let j=0;j<this.numInputs;j++){this.weightsIH[i][j]+=lr*gH[i]*a[j];}this.biasH[i]+=lr*gH[i];}}}}
  transpose(m){return m[0].map((_,c)=>m.map(r=>r[c]));}
  exportState(){return{weightsIH:this.weightsIH,weightsHO:this.weightsHO,biasH:this.biasH,biasO:this.biasO,numInputs:this.numInputs,numHidden:this.numHidden,numOutputs:this.numOutputs};}
  importState(s){if(s.numInputs!==this.numInputs||s.numHidden!==this.numHidden||s.numOutputs!==this.numOutputs){console.error("Arquitetura incompat√≠vel");return!1;}this.weightsIH=s.weightsIH;this.weightsHO=s.weightsHO;this.biasH=s.biasH;this.biasO=s.biasO;return!0;}
}
class MapNeuralManager {
    constructor(){this.numInputs=4;this.numHidden=6;this.numOutputs=1;this.neuralNet=new SimpleNeuralNet(this.numInputs,this.numHidden,this.numOutputs);this.trainingData={inputs:[],targets:[]};this.maxSubtasksForNormalization=5; const STORAGE_KEYS = window.STORAGE_KEYS || {};}
    _normalizeTaskFeatures(t){const pMap={baixa:.2,media:.5,alta:.8},uP=pMap[t.priority]||.5;let dP=0;if(t.dueDate){const e=new Date,a=new Date(t.dueDate+"T00:00:00Z");e.setHours(0,0,0,0);const s=Math.ceil((a-e)/864e5);s<=0?dP=1:s<=3?dP=.8:s<=7?dP=.6:s<=14?dP=.4:dP=.2}const nS=Math.min((t.subtasks?.length||0)/this.maxSubtasksForNormalization,1),hR=t.responsible?.trim()!==""?1:0;return[uP,dP,nS,hR];}
    getTaskPriorityPrediction(t){return t.completed?0:this.neuralNet.predict(this._normalizeTaskFeatures(t)).finalOutputs[0];}
    addTrainingSample(t,p){this.trainingData.inputs.push(this._normalizeTaskFeatures(t));this.trainingData.targets.push([p]);this.saveTrainingData();}
    trainNetwork(epochs=500,lr=.05){if(this.trainingData.inputs.length===0)return;this.neuralNet.train(this.trainingData.inputs,this.trainingData.targets,epochs,lr);this.saveState();}
    saveState(){localStorage.setItem('webos_map_neural_state_v1.0',JSON.stringify(this.neuralNet.exportState()));}
    loadState(){const s=localStorage.getItem('webos_map_neural_state_v1.0');if(s)try{const p=JSON.parse(s);this.neuralNet.importState(p)||console.warn("Falha ao importar estado.");}catch(e){console.error("Erro ao carregar estado.",e);}this.loadTrainingData();}
    saveTrainingData(){localStorage.setItem('webos_map_neural_training_v1.0',JSON.stringify(this.trainingData));}
    loadTrainingData(){const d=localStorage.getItem('webos_map_neural_training_v1.0');if(d)try{this.trainingData=JSON.parse(d);}catch(e){console.error("Erro ao carregar treino.",e);this.trainingData={inputs:[],targets:[]};}}
}
window.mapNeuralManager = new MapNeuralManager();
