<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="utf-8"/>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <title>WebOS Gestão Pública PRO v2.0 (Firebase + Google Drive)</title>
    
    <!-- APIs e Bibliotecas -->
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client" async defer></script>

    <!-- Estilos e Fontes -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&amp;display=swap" rel="stylesheet"/>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" rel="stylesheet"/>
    <link href="https://cdn.jsdelivr.net/npm/jsmind@0.4.6/style/jsmind.css" rel="stylesheet"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

<style>
    :root {
        /* Tema Sonoma Claro (Padrão) */
        --accent-light: #007AFF; --background-light: #f0f0f5; --text-light: #1d1d1f;
        --secondary-text-light: #6e6e73; --window-bg-light: rgba(248, 248, 250, 0.90);
        --toolbar-bg-light: rgba(240, 240, 245, 0.82); --button-bg-light: rgba(225, 225, 230, 0.98);
        --button-text-light: #1d1d1f; --input-bg-light: #ffffff; --input-border-light: #d1d1d6;
        --separator-light: rgba(60, 60, 67, 0.29); --hover-highlight-light: rgba(0, 122, 255, 0.1);
        --accent-light-translucent: rgba(0, 122, 255, 0.1); --window-bg-light-rgb: 248,248,250;
        --background-light-rgb: 240,240,245;

        /* Tema Sonoma Escuro */
        --accent-dark: #0A84FF; --background-dark: #121212; --text-dark: #f5f5f7;
        --secondary-text-dark: #8a8a8e; --window-bg-dark: rgba(32, 32, 34, 0.90);
        --toolbar-bg-dark: rgba(44, 44, 46, 0.82); --button-bg-dark: rgba(72, 72, 74, 0.98);
        --button-text-dark: #f5f5f7; --input-bg-dark: #2c2c2e; --input-border-dark: #545458;
        --separator-dark: rgba(84, 84, 88, 0.65); --hover-highlight-dark: rgba(10, 132, 255, 0.15);
        --accent-dark-translucent: rgba(10, 132, 255, 0.15); --window-bg-dark-rgb: 32,32,34;
        --background-dark-rgb: 18,18,18;

        /* Variáveis Ativas */
        --accent-color: var(--accent-light); --background: var(--background-light);
        --text-color: var(--text-light); --secondary-text-color: var(--secondary-text-light);
        --window-bg: var(--window-bg-light); --toolbar-bg: var(--toolbar-bg-light);
        --button-bg: var(--button-bg-light); --button-text-color: var(--button-text-light);
        --input-bg: var(--input-bg-light); --input-border-color: var(--input-border-light);
        --separator-color: var(--separator-light); --hover-highlight-color: var(--hover-highlight-light);
        --current-window-bg-rgb: var(--window-bg-light-rgb);
        --current-background-rgb-for-stage: var(--background-light-rgb);

        /* Constantes de Layout e Estilo */
        --sonoma-blur: blur(28px); --taskbar-height: 48px; --dock-item-size: 58px;
        --dock-padding: 10px; --dock-gap: 14px;
        --dock-total-bottom-offset: calc(var(--taskbar-height) + 10px);
        --shadow: 0 12px 32px rgba(0,0,0,0.25), 0 4px 8px rgba(0,0,0,0.15);
        --window-border-radius: 12px; --button-border-radius: 8px;
        --font-family-system: -apple-system, BlinkMacSystemFont, "Inter", "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
    }
    /* Estilos Gerais (Reset, Body, Desktop, etc.) */
    * { margin: 0; padding: 0; box-sizing: border-box; font-family: var(--font-family-system); -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
    html { font-size: 16px; }
    body {
        background-color: var(--background);
        background-size: cover; background-position: center; background-attachment: fixed;
        height: 100vh; overflow: hidden; color: var(--text-color);
        transition: background-color 0.3s ease-in-out, color 0.3s ease-in-out, background-image 0.5s ease-in-out; user-select: none;
    }
    .desktop { height: calc(100vh - var(--taskbar-height)); position: relative; overflow: hidden; }
    .taskbar { position: fixed; bottom: 0; width: 100%; height: var(--taskbar-height); background: var(--toolbar-bg); backdrop-filter: var(--sonoma-blur); -webkit-backdrop-filter: var(--sonoma-blur); display: flex; align-items: center; padding: 0 15px; gap: 10px; border-top: 1px solid var(--separator-color); z-index: 2000; }
    .dock { position: fixed; bottom: var(--dock-total-bottom-offset); left: 50%; transform: translateX(-50%); display: flex; gap: var(--dock-gap); background: rgba(230, 230, 230, 0.35); border: 1px solid rgba(255, 255, 255, 0.2); padding: var(--dock-padding); border-radius: 22px; z-index: 2001; backdrop-filter: var(--sonoma-blur); -webkit-backdrop-filter: var(--sonoma-blur); box-shadow: 0 8px 24px rgba(0,0,0,0.3); transition: background-color 0.3s ease, padding 0.2s ease, gap 0.2s ease; perspective: 800px; }
    .dark-mode .dock { background: rgba(25, 25, 27, 0.70); border: 1px solid rgba(255,255,255,0.12); }
    .dock-item { width: var(--dock-item-size); height: var(--dock-item-size); background: transparent; border-radius: 16px; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: calc(var(--dock-item-size) * 0.55); color: var(--text-color); transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1), filter 0.2s ease; transform-style: preserve-3d; }
    .dock-item:hover { transform: translateY(-12px) scale(1.25) rotateY(10deg) rotateX(5deg) translateZ(10px); filter: brightness(1.1); }
    
    /* Estilo de Janelas */
    .window { position: absolute; background: var(--window-bg); border-radius: var(--window-border-radius); box-shadow: var(--shadow); min-width: 380px; min-height: 280px; display: flex; flex-direction: column; transition: opacity 0.25s ease-out, transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), width 0.2s ease-out, height 0.2s ease-out; overflow: hidden; border: 1px solid var(--separator-color); backdrop-filter: var(--sonoma-blur); -webkit-backdrop-filter: var(--sonoma-blur); transform-origin: bottom center; }
    .window.maximized { width: 100% !important; height: calc(100vh - var(--taskbar-height)) !important; top: 0 !important; left: 0 !important; border-radius: 0; border: none; backdrop-filter: none; }
    .window.minimized { transform: translateY(calc(100vh - var(--taskbar-height) + 70px)) scale(0.1) skewX(30deg); opacity: 0; pointer-events: none; }
    .title-bar { height: 40px; padding: 0 12px; background: transparent !important; color: var(--text-color); display: flex; align-items: center; justify-content: flex-start; position: relative; cursor: grab; user-select: none; flex-shrink: 0; }
    .window-controls { display:flex; gap:8px; align-items: center; padding-right: 10px; }
    .title-bar .window-title-text { flex-grow: 1; text-align: center; font-size: 0.88em; color: var(--text-color); font-weight: 600; line-height: 40px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .window-control { width: 12px; height: 12px; border: none; border-radius: 50%; cursor:pointer; transition:filter 0.15s ease; text-indent: -9999px; }
    .window-control.close { background-color: #ff5f57; } .window-control.minimize { background-color: #ffbd2e; } .window-control.maximize { background-color: #28c940; }
    .window-control:hover { filter: brightness(0.85); }
    .window-content { flex:1; overflow:auto; display: flex; flex-direction: column; border-top: 1px solid var(--separator-color); }
    .window-content:not([class*="-container"]) { padding: 15px; }
    .resize-handle { width: 16px; height: 16px; position: absolute; bottom: 0; right: 0; cursor: se-resize; z-index: 1; }
    
    /* Barra de Tarefas, Relógio, etc. */
    .taskbar-items { display:flex; gap:8px; height:100%; align-items:center; overflow-x: auto; margin-left: 15px;}
    .taskbar-item { padding: 6px 12px; border-radius: var(--button-border-radius); background: var(--button-bg); color: var(--button-text-color); cursor: pointer; transition:all 0.2s ease; display:flex; align-items:center; gap:6px; height: calc(var(--taskbar-height) - 16px); font-size: 0.85em; max-width: 160px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; border: 1px solid transparent; position: relative; }
    .taskbar-item:hover { filter: brightness(0.95); }
    .taskbar-item.active { background: var(--accent-color); color: white; border-color: var(--accent-color); font-weight: 600; }
    .clock { margin-left: auto; font-weight: 600; color:var(--text-color); padding: 6px 10px; border-radius: var(--button-border-radius); background: var(--button-bg); font-variant-numeric: tabular-nums; font-size: 0.9em; }

    /* Controles de UI (Botões, Inputs) */
    .app-input, .app-textarea, .app-select { width: 100%; padding: 9px 12px; margin-bottom: 12px; border-radius: var(--button-border-radius); border: 1px solid var(--input-border-color); background-color: var(--input-bg); color: var(--text-color); font-size: 0.95em; transition: border-color 0.2s ease, box-shadow 0.2s ease; }
    .app-input:focus, .app-textarea:focus, .app-select:focus { border-color: var(--accent-color); box-shadow: 0 0 0 2px var(--accent-light-translucent, rgba(0,122,255,0.2)); outline:none;}
    .app-button { padding: 9px 16px; border-radius: var(--button-border-radius); border: none; background-color: var(--accent-color); color: white; cursor: pointer; font-weight: 600; font-size:0.9em; transition: filter 0.15s ease, transform 0.1s ease; }
    .app-button:hover { filter: brightness(1.1); } .app-button:active { transform: scale(0.98); }
    .app-button.secondary { background-color: var(--button-bg); color: var(--button-text-color); border: 1px solid var(--input-border-color); }
    .app-button:disabled { background-color: var(--button-bg); color: var(--secondary-text-color); cursor: not-allowed; filter: grayscale(50%); }

    /* Explorador de Arquivos */
    .file-explorer { display:flex; height:100%; background-color: var(--window-bg);}
    .file-tree { width:280px; border-right:1px solid var(--separator-color); padding:10px; overflow-y:auto; flex-shrink: 0; }
    .file-tree-item { padding: 7px 5px; cursor: pointer; display: flex; align-items: center; border-radius: 5px; font-size: 0.9em;}
    .file-tree-item:hover { background-color: var(--hover-highlight-color); }
    .file-tree-item.selected { background-color: var(--accent-color); color:white; }
    .file-tree-item span { margin-left: 7px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .file-tree-item .item-icon { margin-right: 7px; width: 18px; display: inline-block; text-align: center; opacity: 0.8; }
    .file-content { flex:1; padding:12px; overflow-y: auto; }

    /* Mapa Mental */
    .mindmap-container { flex-grow: 1; overflow: hidden; background: var(--window-bg); }
    
    /* Notificações e Tela de Login */
    #notification { position:fixed; bottom: calc(var(--taskbar-height) + 15px); right:20px; background:rgba(28,28,30,0.9); backdrop-filter: blur(18px); -webkit-backdrop-filter: blur(18px); color:white; padding:12px 20px; border-radius: var(--button-border-radius); display:none; z-index:3000; transition: opacity 0.3s ease, transform 0.3s ease; opacity: 0; transform: translateY(20px); box-shadow: 0 5px 15px rgba(0,0,0,0.35); font-size: 0.95em; }
    #notification.show { display: block; opacity: 1; transform: translateY(0); }
    .login-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); z-index: 10000; display: flex; justify-content: center; align-items: center; opacity: 0; transition: opacity 0.3s; pointer-events: none; }
    .login-overlay.visible { opacity: 1; pointer-events: auto; }
    .login-box { background: var(--window-bg); padding: 40px; border-radius: var(--window-border-radius); text-align: center; box-shadow: var(--shadow); width: 90%; max-width: 400px; }
    .login-box h2 { margin-bottom: 10px; } .login-box p { margin-bottom: 25px; color: var(--secondary-text-color); }
    #googleLoginBtn { display: inline-flex; align-items: center; gap: 10px; font-size: 1.1em; padding: 12px 20px; }
    #googleLoginBtn img { width: 24px; height: 24px; }
    .loading-spinner { border: 4px solid var(--button-bg); border-top: 4px solid var(--accent-color); border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; margin: 20px auto 0; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    
    /* Perfil do Usuário na Taskbar */
    .user-profile { display: flex; align-items: center; gap: 8px; margin-left: 15px; background: var(--button-bg); padding: 5px 10px; border-radius: var(--button-border-radius); cursor: pointer; }
    .user-profile img { width: 28px; height: 28px; border-radius: 50%; border: 2px solid var(--separator-color); }
    .user-profile span { font-weight: 500; font-size: 0.9em; }

    /* Tema Escuro */
    .dark-mode { --accent-color: var(--accent-dark); --background: var(--background-dark); --text-color: var(--text-dark); --secondary-text-color: var(--secondary-text-dark); --window-bg: var(--window-bg-dark); --toolbar-bg: var(--toolbar-bg-dark); --button-bg: var(--button-bg-dark); --button-text-color: var(--button-text-dark); --input-bg: var(--input-bg-dark); --input-border-color: var(--input-border-dark); --separator-color: var(--separator-dark); --hover-highlight-color: var(--hover-highlight-dark); --current-window-bg-rgb: var(--window-bg-dark-rgb); --current-background-rgb-for-stage: var(--background-dark-rgb); }
    /* Adicione outros estilos específicos de aplicativos aqui, se necessário */
    .swot-analysis-app-container, .sipoc-matrix-app-container, .kanban-board-app { padding: 0 !important; }

</style>
</head>
<body class="dark-mode">

<!-- Overlay de Login -->
<div id="loginOverlay" class="login-overlay">
    <div class="login-box">
        <h2>Bem-vindo ao WebOS Gestão Pública</h2>
        <p>Faça login com sua conta Google para salvar e acessar seus arquivos no Google Drive.</p>
        <button id="googleLoginBtn" class="app-button">
            <img src="https://www.google.com/favicon.ico" alt="Google icon">
            <span>Entrar com Google</span>
        </button>
        <div id="loginSpinner" class="loading-spinner" style="display: none;"></div>
    </div>
</div>

<div class="desktop" id="desktop" style="display: none;">
    <!-- Janelas dos aplicativos serão adicionadas aqui -->
</div>

<div class="dock" id="appDock" style="display: none;">
    <!-- Ícones dos aplicativos -->
    <div class="dock-item" data-action="open-file-system" title="Explorador de Arquivos (Drive)">📁</div>
    <div class="dock-item" data-action="open-mind-map" title="Mapa Mental">🧠</div>
    <!-- Outros ícones de apps que você queira manter -->
    <div class="dock-item" data-action="open-gantt-chart" title="Cronograma (Gantt)">📊</div>
    <div class="dock-item" data-action="open-project-tasks" title="Tarefas de Projeto">✅</div>
    <div class="dock-item" data-action="open-kanban-board" title="Kanban Board">📋</div>
    <div class="dock-item" data-action="open-swot-analysis" title="Matriz SWOT">📝</div>
    <div class="dock-item" data-action="open-sipoc-matrix" title="Matriz SIPOC">🧩</div>
</div>

<div class="taskbar" id="taskbar" style="display: none;">
    <div class="taskbar-items" id="taskbarItems"></div>
    <div id="userProfile" class="user-profile" style="display: none;">
        <img id="userAvatar" src="">
        <span id="userName"></span>
    </div>
    <button class="app-button secondary" id="logoutBtn" style="display: none;">Sair</button>
    <button class="app-button secondary" id="darkModeToggle" title="Modo Escuro">🌙</button>
    <div class="clock" id="clock">00:00</div>
</div>

<div id="notification">Mensagem de Notificação</div>

<script type="module">
    // Importações do Firebase SDK
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
    import { getAuth, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-auth.js";

    // --- 1. CONFIGURAÇÃO E AUTENTICAÇÃO ---

    // Configuração do Firebase fornecida pelo usuário
    const firebaseConfig = {
        apiKey: "AIzaSyCbpWXt9stM8jnIL3UIggZuvr3V7nwvPcQ",
        authDomain: "publicmanagementos.firebaseapp.com",
        projectId: "publicmanagementos",
        storageBucket: "publicmanagementos.appspot.com", // corrigido para o padrão
        messagingSenderId: "829309037744",
        appId: "1:829309037744:web:3276773141117bb8255f75",
        measurementId: "G-JQ2XPCN68T"
    };

    // Inicialização do Firebase
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);

    // Configuração da API do Google
    const GOOGLE_API_KEY = firebaseConfig.apiKey; // Reutilizando a chave de API
    const GOOGLE_CLIENT_ID = '829309037744-25gvhshda8k2s4kuq44k898ki9qjifb8.apps.googleusercontent.com'; // O ID do cliente OAuth 2.0 deve ser criado no Google Cloud Console
    const DISCOVERY_DOCS = ["https://www.googleapis.com/discovery/v1/apis/drive/v3/rest"];
    const SCOPES = 'https://www.googleapis.com/auth/drive.file';
    
    const APP_DRIVE_FOLDER = 'WebOS_GestaoPublica_Files';
    let gapiInited = false;
    let gisInited = false;
    let tokenClient;
    let appFolderId = null;

    const loginOverlay = document.getElementById('loginOverlay');
    const loginBtn = document.getElementById('googleLoginBtn');
    const logoutBtn = document.getElementById('logoutBtn');
    const loginSpinner = document.getElementById('loginSpinner');

    // Monitora o estado de autenticação do usuário
    onAuthStateChanged(auth, async (user) => {
        if (user) {
            // Usuário está logado
            console.log("Usuário logado:", user.displayName);
            await initializeGoogleApis(user);
            updateUIForLoggedInUser(user);
            initializeWebOS(); 
        } else {
            // Usuário está deslogado
            console.log("Nenhum usuário logado.");
            updateUIForLoggedOutUser();
        }
    });

    // Função para inicializar as APIs do Google
    async function initializeGoogleApis(user) {
        // Obter o token de acesso do Firebase para o usuário atual
        const idToken = await user.getIdToken(true);
        
        // GAPI (para chamadas à API do Drive)
        await new Promise((resolve) => gapi.load('client', resolve));
        await gapi.client.init({
            apiKey: GOOGLE_API_KEY,
            discoveryDocs: DISCOVERY_DOCS,
        });

        // GIS (para obter o token de acesso OAuth2 do Google)
        tokenClient = google.accounts.oauth2.initTokenClient({
            client_id: GOOGLE_CLIENT_ID,
            scope: SCOPES,
            callback: '', // O token será retornado na promessa
        });
        
        // Definindo o token de acesso para as chamadas gapi
        // Isso é feito solicitando um token de acesso OAuth2
        await new Promise((resolve, reject) => {
            tokenClient.callback = (resp) => {
                if (resp.error !== undefined) {
                    reject(resp);
                }
                gapi.client.setToken({ access_token: resp.access_token });
                console.log("Token de acesso do Google obtido com sucesso.");
                resolve(resp);
            };
            tokenClient.requestAccessToken({ prompt: 'none' });
        });

        // Verifica/cria a pasta do aplicativo no Google Drive
        appFolderId = await getOrCreateAppFolder();
    }


    // Handlers dos botões de login/logout
    loginBtn.onclick = async () => {
        loginSpinner.style.display = 'block';
        loginBtn.style.display = 'none';
        try {
            const provider = new GoogleAuthProvider();
            // Adiciona o escopo do Google Drive à solicitação de login
            provider.addScope(SCOPES);
            await signInWithPopup(auth, provider);
        } catch (error) {
            console.error("Erro no login com Google:", error);
            showNotification("Falha no login. Tente novamente.", 4000);
            loginSpinner.style.display = 'none';
            loginBtn.style.display = 'inline-flex';
        }
    };

    logoutBtn.onclick = async () => {
        await signOut(auth);
        // Revoga o token do GSI para forçar um novo login da próxima vez
        if (gapi.client.getToken()) {
            google.accounts.oauth2.revoke(gapi.client.getToken().access_token, () => {
                console.log('Token de acesso do Google revogado.');
            });
            gapi.client.setToken('');
        }
    };
    
    function updateUIForLoggedInUser(user) {
        loginOverlay.classList.remove('visible');
        document.getElementById('desktop').style.display = 'block';
        document.getElementById('appDock').style.display = 'flex';
        document.getElementById('taskbar').style.display = 'flex';

        const userProfile = document.getElementById('userProfile');
        document.getElementById('userName').textContent = user.displayName;
        document.getElementById('userAvatar').src = user.photoURL;
        userProfile.style.display = 'flex';
        logoutBtn.style.display = 'block';
    }

    function updateUIForLoggedOutUser() {
        loginOverlay.classList.add('visible');
        loginSpinner.style.display = 'none';
        loginBtn.style.display = 'inline-flex';
        document.getElementById('desktop').style.display = 'none';
        document.getElementById('appDock').style.display = 'none';
        document.getElementById('taskbar').style.display = 'none';
        document.getElementById('userProfile').style.display = 'none';
        logoutBtn.style.display = 'none';
        // Limpa a área de trabalho ao deslogar
        document.getElementById('desktop').innerHTML = '';
        document.getElementById('taskbarItems').innerHTML = '';
    }

    // --- 2. GOOGLE DRIVE API WRAPPER ---
    
    /**
     * Obtém o ID da pasta do aplicativo no Google Drive. Se não existir, cria uma.
     * @returns {Promise<string>} O ID da pasta.
     */
    async function getOrCreateAppFolder() {
        try {
            const response = await gapi.client.drive.files.list({
                q: `mimeType='application/vnd.google-apps.folder' and name='${APP_DRIVE_FOLDER}' and trashed=false`,
                fields: 'files(id, name)'
            });
            if (response.result.files && response.result.files.length > 0) {
                console.log(`Pasta '${APP_DRIVE_FOLDER}' encontrada, ID:`, response.result.files[0].id);
                return response.result.files[0].id;
            } else {
                console.log(`Pasta '${APP_DRIVE_FOLDER}' não encontrada. Criando...`);
                const fileMetadata = {
                    'name': APP_DRIVE_FOLDER,
                    'mimeType': 'application/vnd.google-apps.folder'
                };
                const createResponse = await gapi.client.drive.files.create({
                    resource: fileMetadata,
                    fields: 'id'
                });
                console.log('Pasta criada, ID:', createResponse.result.id);
                return createResponse.result.id;
            }
        } catch (error) {
            console.error("Erro ao obter/criar pasta no Drive:", error);
            showNotification("Erro de comunicação com o Google Drive.", 4000);
            return null;
        }
    }

    /**
     * Lista os arquivos da pasta do aplicativo no Google Drive.
     * @returns {Promise<Array>} Uma lista de objetos de arquivo.
     */
    async function listDriveFiles() {
        if (!appFolderId) {
            showNotification("Pasta do aplicativo no Drive não está acessível.", 3000);
            return [];
        }
        try {
            const response = await gapi.client.drive.files.list({
                q: `'${appFolderId}' in parents and trashed=false`,
                fields: 'files(id, name, mimeType, appProperties)',
                orderBy: 'name'
            });
            console.log("Arquivos do Drive:", response.result.files);
            return response.result.files || [];
        } catch (error) {
            console.error("Erro ao listar arquivos do Drive:", error);
            showNotification("Não foi possível carregar os arquivos do Drive.", 3000);
            return [];
        }
    }

    /**
     * Lê o conteúdo de um arquivo do Google Drive.
     * @param {string} fileId - O ID do arquivo.
     * @returns {Promise<string>} O conteúdo do arquivo.
     */
    async function readFileFromDrive(fileId) {
        try {
            const response = await gapi.client.drive.files.get({
                fileId: fileId,
                alt: 'media'
            });
            return response.body;
        } catch (error) {
            console.error("Erro ao ler arquivo do Drive:", error);
            showNotification("Erro ao abrir o arquivo.", 3000);
            return null;
        }
    }

    /**
     * Cria um novo arquivo no Google Drive.
     * @param {string} fileName - O nome do novo arquivo.
     * @param {string} content - O conteúdo do arquivo.
     * @param {string} appDataType - O tipo de dados do app (ex: 'mindmap').
     * @returns {Promise<object>} O objeto do arquivo criado.
     */
    async function createFileInDrive(fileName, content, appDataType) {
        if (!appFolderId) {
            showNotification("Não é possível salvar, pasta do app indisponível.", 3000);
            return null;
        }
        const metadata = {
            name: fileName,
            mimeType: 'application/json',
            parents: [appFolderId],
            appProperties: {
                appDataType: appDataType
            }
        };
        const blob = new Blob([content], {type: 'application/json'});
        const form = new FormData();
        form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
        form.append('file', blob);

        try {
            const response = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {
                method: 'POST',
                headers: new Headers({ 'Authorization': 'Bearer ' + gapi.client.getToken().access_token }),
                body: form,
            });
            const result = await response.json();
            console.log("Arquivo criado no Drive:", result);
            return result;
        } catch (error) {
            console.error("Erro ao criar arquivo no Drive:", error);
            showNotification("Falha ao salvar o novo arquivo.", 3000);
            return null;
        }
    }
    
    /**
     * Atualiza um arquivo existente no Google Drive.
     * @param {string} fileId - O ID do arquivo a ser atualizado.
     * @param {string} content - O novo conteúdo do arquivo.
     * @returns {Promise<object>} O objeto do arquivo atualizado.
     */
    async function updateFileInDrive(fileId, content) {
        const blob = new Blob([content], {type: 'application/json'});
        try {
            const response = await fetch(`https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=media`, {
                method: 'PATCH',
                headers: new Headers({ 'Authorization': 'Bearer ' + gapi.client.getToken().access_token }),
                body: blob,
            });
            const result = await response.json();
            console.log("Arquivo atualizado no Drive:", result);
            return result;
        } catch (error) {
            console.error("Erro ao atualizar arquivo no Drive:", error);
            showNotification("Falha ao salvar as alterações.", 3000);
            return null;
        }
    }

    /**
     * Exclui um arquivo do Google Drive.
     * @param {string} fileId - O ID do arquivo.
     * @returns {Promise<boolean>} Sucesso ou falha.
     */
    async function deleteFileFromDrive(fileId) {
        try {
            await gapi.client.drive.files.delete({
                fileId: fileId
            });
            return true;
        } catch (error) {
            console.error("Erro ao excluir arquivo do Drive:", error);
            showNotification("Falha ao excluir o arquivo.", 3000);
            return false;
        }
    }
    
    /**
     * Renomeia um arquivo no Google Drive.
     * @param {string} fileId - O ID do arquivo.
     * @param {string} newName - O novo nome do arquivo.
     * @returns {Promise<boolean>} Sucesso ou falha.
     */
    async function renameFileInDrive(fileId, newName) {
        try {
            await gapi.client.drive.files.update({
                fileId: fileId,
                resource: { name: newName }
            });
            return true;
        } catch (error) {
            console.error("Erro ao renomear arquivo do Drive:", error);
            showNotification("Falha ao renomear o arquivo.", 3000);
            return false;
        }
    }

    // --- 3. LÓGICA DO WEBOS MODIFICADA ---
    
    // O WindowManager, ThemeManager, etc., permanecem em grande parte os mesmos
    // As principais alterações estão na lógica de salvamento e no FileSystem.

    function generateId(prefix = 'id') { return prefix + '_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now(); }
    function showNotification(message, duration = 3000) { const el = document.getElementById('notification'); if (!el) return; el.textContent = message; el.classList.add('show'); setTimeout(() => el.classList.remove('show'), duration); }
    
    // Substituída a função de salvar localmente
    async function handleSaveAction(appState) {
        if (!auth.currentUser) {
            showNotification("Faça login para salvar seus arquivos.", 3000);
            return;
        }
        const dataToSave = appState.getData();
        const jsonString = JSON.stringify(dataToSave, null, 2);
        
        showNotification("Salvando no Google Drive...", 2000);
        
        if (appState.currentFileHandle && appState.currentFileHandle.id) {
            // Salvar (sobrescrever) arquivo existente
            await updateFileInDrive(appState.currentFileHandle.id, jsonString);
            appState.markClean();
            showNotification(`"${appState.currentFileHandle.name}" salvo com sucesso.`, 2500);
        } else {
            // Salvar Como... (criar novo arquivo)
            await handleSaveAsAction(appState);
        }
    }

    async function handleSaveAsAction(appState) {
        if (!auth.currentUser) {
            showNotification("Faça login para salvar seus arquivos.", 3000);
            return;
        }
        const defaultFilename = (appState.currentFileHandle?.name) || appState.defaultFileName;
        const newFilename = prompt("Salvar arquivo no Google Drive como:", defaultFilename);

        if (newFilename) {
            const dataToSave = appState.getData();
            const jsonString = JSON.stringify(dataToSave, null, 2);
            showNotification(`Criando "${newFilename}"...`, 2000);
            const createdFile = await createFileInDrive(newFilename, jsonString, appState.appDataType);
            if(createdFile) {
                // Atualiza o handle do arquivo no estado do app
                appState.currentFileHandle = { id: createdFile.id, name: newFilename };
                appState.markClean();
                windowManager.updateWindowTitle(appState.winId, newFilename);
                showNotification(`Arquivo salvo como "${newFilename}".`, 2500);
                // Atualiza a árvore do explorador se estiver aberta
                if (fileSystemExplorerInstance) fileSystemExplorerInstance.refreshTree();
            }
        }
    }
    
    // Importar arquivo do computador continua útil
    function importFileFromComputer(file, appState) {
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (evt) => {
            // Limpa o handle atual, pois é um arquivo importado não salvo no Drive
            appState.loadData(evt.target.result, null); 
            windowManager.updateWindowTitle(appState.winId, `*Importado: ${file.name}`);
            appState.isDirty = true; // Marca como sujo para forçar "Salvar Como"
            showNotification(`"${file.name}" importado. Salve no Drive para manter.`, 4000);
        };
        reader.readAsText(file);
    }
    
    class WindowManager {
        // ... (A classe WindowManager pode ser copiada da sua versão original)
        // Nenhuma alteração significativa é necessária nela para esta funcionalidade.
        // Apenas para garantir que o código completo esteja aqui, irei incluir uma versão resumida.
        constructor() {
            this.windows = new Map();
            this.zIndex = 100;
            this.activeWindowId = null;
            this.taskbarItemsContainer = document.getElementById('taskbarItems');
            this.appLaunchActions = {};
        }

        createWindow(title, content, options = {}) {
            const winId = generateId('win');
            this.zIndex++;

            const win = document.createElement('div');
            win.id = winId;
            win.className = 'window';
            win.style.width = options.width || '700px';
            win.style.height = options.height || '500px';
            const taskbarHeightVal = 48;
            const maxLeft = window.innerWidth - parseInt(win.style.width, 10) - 20;
            const maxTop = window.innerHeight - parseInt(win.style.height, 10) - taskbarHeightVal - 20;
            win.style.left = `${Math.max(10, Math.random() * maxLeft)}px`;
            win.style.top = `${Math.max(10, Math.random() * maxTop)}px`;
            win.style.zIndex = this.zIndex;

            const titleBar = document.createElement('div');
            titleBar.className = 'title-bar';
            
            const controls = document.createElement('div');
            controls.className = 'window-controls';
            ['close', 'minimize', 'maximize'].forEach(type => {
                const btn = document.createElement('button');
                btn.className = `window-control ${type}`;
                btn.onclick = (e) => { e.stopPropagation(); this[type+'Window'](winId); };
                controls.appendChild(btn);
            });

            const titleText = document.createElement('span');
            titleText.className = 'window-title-text';
            titleText.textContent = title;

            const windowContent = document.createElement('div');
            windowContent.className = 'window-content';
            if (options.appType) windowContent.classList.add(`${options.appType}-container`);
            if (typeof content === 'string') windowContent.innerHTML = content;
            else if (content instanceof HTMLElement) windowContent.appendChild(content);

            const resizeHandle = document.createElement('div');
            resizeHandle.className = 'resize-handle';
            
            win.addEventListener('keydown', (e) => {
                if (e.ctrlKey && e.key.toLowerCase() === 's') {
                    e.preventDefault();
                    const activeWinData = this.windows.get(this.activeWindowId);
                    if (activeWinData && activeWinData.currentAppInstance) {
                        handleSaveAction(activeWinData.currentAppInstance);
                    }
                }
            });

            titleBar.appendChild(controls);
            titleBar.appendChild(titleText);
            win.appendChild(titleBar);
            win.appendChild(windowContent);
            win.appendChild(resizeHandle);
            document.getElementById('desktop').appendChild(win);

            const winData = { element: win, title: title, minimized: false, maximized: false, appType: options.appType || 'generic', currentAppInstance: null };
            this.windows.set(winId, winData);
            this.makeActive(winId);
            this._addDragAndResize(win, titleBar, resizeHandle, winId);
            this._createTaskbarItem(winId, title, options.appType);

            win.addEventListener('mousedown', () => this.makeActive(winId));
            return winId;
        }

        makeActive(winId) {
            if (this.activeWindowId && this.windows.has(this.activeWindowId)) {
                this.windows.get(this.activeWindowId).element.classList.remove('active');
            }
            if (this.windows.has(winId)) {
                const winData = this.windows.get(winId);
                this.zIndex++;
                winData.element.style.zIndex = this.zIndex;
                winData.element.classList.add('active');
                this.activeWindowId = winId;
                this._updateTaskbarActiveState(winId);
            }
        }
        
        closeWindow(winId) {
            if (this.windows.has(winId)) {
                const winData = this.windows.get(winId);
                if (winData.currentAppInstance && winData.currentAppInstance.isDirty) {
                    if (!confirm('Você tem alterações não salvas. Deseja fechar e descartar?')) {
                        return;
                    }
                }
                winData.element.remove();
                this.windows.delete(winId);
                this._removeTaskbarItem(winId);
                if (this.activeWindowId === winId) this.activeWindowId = null;
            }
        }

        minimizeWindow(winId) { if(this.windows.has(winId)) this.windows.get(winId).element.classList.add('minimized'); }
        maximizeWindow(winId) { if(this.windows.has(winId)) this.windows.get(winId).element.classList.toggle('maximized'); }
        restoreWindow(winId) { if(this.windows.has(winId)) { this.windows.get(winId).element.classList.remove('minimized'); this.makeActive(winId); } }

        updateWindowTitle(winId, newTitle) {
            if (this.windows.has(winId)) {
                const winData = this.windows.get(winId);
                winData.title = newTitle;
                winData.element.querySelector('.window-title-text').textContent = newTitle;
                this._updateTaskbarItemTitle(winId, newTitle);
            }
        }

        // Métodos privados (_addDragAndResize, _createTaskbarItem, etc.) podem ser copiados da versão original.
        // Eles não precisam de alterações. Para brevidade, omitidos aqui.
         _addDragAndResize(win, titleBar, resizeHandle, winId) { /* ... */ }
        _createTaskbarItem(winId, title) { const item = document.createElement('div'); item.className = 'taskbar-item'; item.id = `taskbar-item-${winId}`; item.textContent = title; item.onclick = () => { const winData = this.windows.get(winId); if (winData.minimized) this.restoreWindow(winId); else if(this.activeWindowId === winId) this.minimizeWindow(winId); else this.makeActive(winId); }; this.taskbarItemsContainer.appendChild(item); }
        _removeTaskbarItem(winId) { const item = document.getElementById(`taskbar-item-${winId}`); if(item) item.remove(); }
        _updateTaskbarItemTitle(winId, newTitle) { const item = document.getElementById(`taskbar-item-${winId}`); if(item) item.textContent = newTitle; }
        _updateTaskbarActiveState(winIdToActivate) { this.taskbarItemsContainer.querySelectorAll('.taskbar-item').forEach(item => item.classList.remove('active')); const activeItem = document.getElementById(`taskbar-item-${winIdToActivate}`); if(activeItem) activeItem.classList.add('active'); }
    }
    
    // Instância global do WindowManager
    const windowManager = new WindowManager();
    
    // --- Classe FileSystemExplorer (Substitui a antiga classe FileSystem) ---
    class FileSystemExplorer {
        constructor(winId) {
            this.winId = winId;
            this.winEl = document.getElementById(winId);
            this.treeCont = this.winEl.querySelector('.file-tree');
            this.detailsDiv = this.winEl.querySelector('.file-content'); // Simplificado
            this.files = [];
            this.selectedFileId = null;

            this.refreshTree();
            
            // Adicionar listeners para botões, etc.
            this.treeCont.addEventListener('click', (e) => {
                const itemEl = e.target.closest('.file-tree-item');
                if (itemEl) {
                    this.selectFile(itemEl.dataset.fileId);
                }
            });
            this.detailsDiv.addEventListener('dblclick', () => this.openSelectedFile());
        }

        async refreshTree() {
            this.treeCont.innerHTML = '<div class="loading-spinner"></div>';
            this.files = await listDriveFiles();
            this.treeCont.innerHTML = '';
            
            if (this.files.length === 0) {
                this.treeCont.innerHTML = '<p style="padding: 10px; color: var(--secondary-text-color);">Nenhum arquivo encontrado.</p>';
            } else {
                this.files.forEach(file => {
                    const itemEl = document.createElement('div');
                    itemEl.className = 'file-tree-item';
                    itemEl.dataset.fileId = file.id;
                    const icon = this.getIconForFile(file);
                    itemEl.innerHTML = `<span class="item-icon">${icon}</span><span>${file.name}</span>`;
                    this.treeCont.appendChild(itemEl);
                });
            }
        }
        
        getIconForFile(file) {
            const appDataType = file.appProperties?.appDataType;
            const appIcons = { 'mindmap': '🧠', 'gantt': '📊', 'project-tasks': '✅', 'kanban': '📋', 'swot': '📝', 'sipoc': '🧩' };
            return appIcons[appDataType] || '📄';
        }

        selectFile(fileId) {
            this.selectedFileId = fileId;
            this.treeCont.querySelectorAll('.file-tree-item').forEach(el => {
                el.classList.toggle('selected', el.dataset.fileId === fileId);
            });
            this.renderDetails();
        }

        renderDetails() {
            if (!this.selectedFileId) {
                this.detailsDiv.innerHTML = '<p>Selecione um arquivo.</p>';
                return;
            }
            const file = this.files.find(f => f.id === this.selectedFileId);
            if (file) {
                 this.detailsDiv.innerHTML = `
                    <h4>${file.name}</h4>
                    <p>Tipo: ${file.appProperties?.appDataType || 'Arquivo'}</p>
                    <button id="openFileBtn" class="app-button">Abrir</button>
                    <button id="renameFileBtn" class="app-button secondary">Renomear</button>
                    <button id="deleteFileBtn" class="app-button danger">Excluir</button>`;
                    
                document.getElementById('openFileBtn').onclick = () => this.openSelectedFile();
                document.getElementById('renameFileBtn').onclick = () => this.renameSelectedFile();
                document.getElementById('deleteFileBtn').onclick = () => this.deleteSelectedFile();
            }
        }
        
        async openSelectedFile() {
             if (!this.selectedFileId) return;
             const file = this.files.find(f => f.id === this.selectedFileId);
             if (!file) return;

             showNotification(`Abrindo "${file.name}"...`, 2000);
             const content = await readFileFromDrive(file.id);
             if (content === null) return;

             const appDataType = file.appProperties?.appDataType;
             const openAction = windowManager.appLaunchActions[`open-${appDataType}`];
             
             if (openAction) {
                const newWinId = openAction();
                const appInstance = windowManager.windows.get(newWinId)?.currentAppInstance;
                if(appInstance) {
                    appInstance.loadData(content, { id: file.id, name: file.name });
                }
             } else {
                 showNotification(`Nenhum app associado para tipo '${appDataType}'`, 3000);
             }
        }
        
        async renameSelectedFile() {
             if (!this.selectedFileId) return;
             const file = this.files.find(f => f.id === this.selectedFileId);
             if (!file) return;
             
             const newName = prompt("Novo nome para o arquivo:", file.name);
             if (newName && newName !== file.name) {
                const success = await renameFileInDrive(this.selectedFileId, newName);
                if(success) {
                    showNotification("Arquivo renomeado.", 2000);
                    this.refreshTree();
                }
             }
        }
        
        async deleteSelectedFile() {
             if (!this.selectedFileId) return;
             const file = this.files.find(f => f.id === this.selectedFileId);
             if (!file) return;
             
             if(confirm(`Tem certeza que deseja excluir "${file.name}"? Esta ação não pode ser desfeita.`)) {
                const success = await deleteFileFromDrive(this.selectedFileId);
                if(success) {
                    showNotification("Arquivo excluído.", 2000);
                    this.selectedFileId = null;
                    this.detailsDiv.innerHTML = '<p>Selecione um arquivo.</p>';
                    this.refreshTree();
                }
             }
        }
    }
    
    let fileSystemExplorerInstance = null;
    
    function openFileSystem() {
        const winId = windowManager.createWindow('Explorador (Google Drive)', '<div class="file-explorer"><div class="file-tree"></div><div class="file-content"><p>Selecione um arquivo para ver os detalhes.</p></div></div>', {
            width: '800px', height: '550px', appType: 'filesystem'
        });
        const winData = windowManager.windows.get(winId);
        fileSystemExplorerInstance = new FileSystemExplorer(winId);
        winData.currentAppInstance = fileSystemExplorerInstance;
    }

    // --- Funções de Abertura de Aplicativos (Modificadas) ---
    
    function getStandardAppToolbarHTML(uniqueSuffix) {
        // Removido o botão "Salvar no WebOS"
        // Adicionada a capacidade de importar um arquivo local
        return `
            <button data-action="save" class="app-button" title="Salvar (Ctrl+S)"><i class="fas fa-save"></i> Salvar no Drive</button>
            <button data-action="save-as" class="app-button secondary" title="Salvar Como..."><i class="fas fa-file-export"></i> Salvar Como...</button>
            <label for="file-importer-${uniqueSuffix}" class="app-button secondary" title="Importar do Computador..."><i class="fas fa-folder-open"></i> Importar...</label>
            <input type="file" id="file-importer-${uniqueSuffix}" accept=".json" style="display:none;"/>
        `;
    }

    function initializeFileState(appState, defaultTitle, defaultFileName, appDataType) {
        appState.isDirty = false;
        appState.currentFileHandle = null; // Agora armazena {id, name} do Drive
        appState.defaultFileName = defaultFileName;
        appState.appDataType = appDataType; // ex: 'mindmap'

        appState.markDirty = function() {
            if (!this.isDirty) {
                this.isDirty = true;
                const currentWin = windowManager.windows.get(this.winId);
                if (currentWin && !currentWin.title.startsWith('*')) {
                    windowManager.updateWindowTitle(this.winId, '*' + currentWin.title);
                }
            }
        };

        appState.markClean = function() {
            this.isDirty = false;
            const currentWin = windowManager.windows.get(this.winId);
            if (currentWin && currentWin.title.startsWith('*')) {
                windowManager.updateWindowTitle(this.winId, currentWin.title.substring(1));
            }
        };

        windowManager.updateWindowTitle(appState.winId, defaultTitle);
    }
    
    function openMindMap() {
        const uniqueSuffix = generateId('mm');
        const content = `
            <div class="mindmap-toolbar app-toolbar">
                 ${getStandardAppToolbarHTML(uniqueSuffix)}
                 <!-- Outros botões específicos do Mind Map aqui -->
                 <button class="app-button" data-action="add-node" title="Adicionar Nó"><i class="fas fa-plus-circle"></i> Nó</button>
            </div>
            <div class="mindmap-container" id="jsmindContainer_${uniqueSuffix}"></div>
        `;
        const winId = windowManager.createWindow('Novo Mapa Mental', content, { width: '950px', height: '650px', appType: 'mindmap' });
        const winData = windowManager.windows.get(winId);

        const appState = {
            winId: winId,
            jmInstance: null,
            getData: function() { return this.jmInstance ? this.jmInstance.get_data('node_tree') : {}; },
            loadData: function(data, fileHandle) {
                if (typeof data === 'string') { try { data = JSON.parse(data); } catch (e) { showNotification("Arquivo de mapa mental inválido.", 3000); return; } }
                if (data.format === "node_tree" && data.data) {
                    this.jmInstance.show(data);
                    this.currentFileHandle = fileHandle;
                    this.markClean();
                    windowManager.updateWindowTitle(this.winId, fileHandle ? fileHandle.name : "*Novo Mapa Mental");
                } else { showNotification("Formato de arquivo inválido.", 3000); }
            },
        };

        initializeFileState(appState, "Novo Mapa Mental", "novo_mapa.json", "mindmap");
        winData.currentAppInstance = appState;
        
        // A lógica de inicialização do jsmind, botões e listeners segue aqui
        // Importante: os botões de salvar/abrir agora chamam as funções globais
        setTimeout(() => {
            if (typeof jsMind !== 'undefined') {
                const options = { container: `jsmindContainer_${uniqueSuffix}`, editable: true, theme: document.body.classList.contains('dark-mode') ? 'dark' : 'primary' };
                const jm = new jsMind(options);
                appState.jmInstance = jm;
                
                const mindData = { meta: {}, format: "node_tree", data: { id: "root", topic: "Tema Central", children: [] } };
                jm.show(mindData);

                const toolbar = winData.element.querySelector('.mindmap-toolbar');
                toolbar.addEventListener('click', (e) => {
                    const action = e.target.closest('button')?.dataset.action;
                    if (action === 'save') handleSaveAction(appState);
                    else if (action === 'save-as') handleSaveAsAction(appState);
                    else if (action === 'add-node') {
                         const selectedNode = jm.get_selected_node();
                         if (!selectedNode) { showNotification("Selecione um nó pai.", 2000); return; }
                         const topic = prompt("Nome do novo nó:", "Novo Tópico");
                         if (topic) { jm.add_node(selectedNode.id, generateId('node'), topic); appState.markDirty(); }
                    }
                });
                toolbar.querySelector(`#file-importer-${uniqueSuffix}`).onchange = (e) => importFileFromComputer(e.target.files[0], appState);
                
                // Marca como sujo ao editar
                winData.element.addEventListener('dblclick', () => { setTimeout(() => { const editor = winData.element.querySelector('.jsmind-editor'); if(editor) editor.oninput = () => appState.markDirty(); }, 100);});
            }
        }, 150);
        return winId;
    }
    
    // --- INICIALIZAÇÃO DO WEBOS ---
    function initializeWebOS() {
        // Atualiza relógio
        setInterval(() => {
            document.getElementById('clock').textContent = new Date().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
        }, 10000);
        
        // Listeners do Dock
        windowManager.appLaunchActions = { 'open-file-system': openFileSystem, 'open-mind-map': openMindMap, /*... outros apps*/ };
        document.querySelectorAll('#appDock .dock-item[data-action]').forEach(item => {
            const action = item.dataset.action;
            if (windowManager.appLaunchActions[action]) {
                item.onclick = () => windowManager.appLaunchActions[action]();
            }
        });
        
        // Listener do modo escuro
        document.getElementById('darkModeToggle').onclick = () => document.body.classList.toggle('dark-mode');

        showNotification(`Bem-vindo, ${auth.currentUser.displayName}!`, 3500);
        // Abre o explorador de arquivos ao iniciar
        openFileSystem();
    }
    
    // Carregamento de scripts JS dos apps
    const jsmindScript = document.createElement('script');
    jsmindScript.src = "https://cdn.jsdelivr.net/npm/jsmind@0.4.6/js/jsmind.js";
    document.head.appendChild(jsmindScript);
    const jsmindDraggableScript = document.createElement('script');
    jsmindDraggableScript.src = "https://cdn.jsdelivr.net/npm/jsmind@0.4.6/js/jsmind.draggable.js";
    document.head.appendChild(jsmindDraggableScript);

</script>
</body>
</html>
